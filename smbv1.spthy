// Tamarin file for modeling SMBv1
theory SMBv1
begin

builtins: signing, revealing-signing

rule SessionSetupRequest:
  []
  --[ St_SessionEstablished() ]->
  [ St_AliceSessionSetup(), St_BobSessionSetup() ]

// rule for Alice's session setup response
rule AliceSessionSetupResponse:
  [ St_AliceSessionSetup() ]
  --[ St_SessionEstablished() ]->
  [ St_AliceSessionEstablished() ]


// rule for Bob's session setup response
rule BobSessionSetupResponse:
  [ St_BobSessionSetup() ]
  --[ St_SessionEstablished() ]->
  [ St_BobSessionEstablished() ]

// rule to affirm 2-person session setup
rule FullSessionSetup:
  [ St_AliceSessionEstablished(), St_BobSessionEstablished() ]
  --[ St_FullSessionEstablished() ]->
  [ St_FullSessionEstablished() ]

// TCP connection
// Alice -> Bob: sync
// Bob -> Alice: sync-acknowledgement
// Alice -> Bob: acknowledgement

rule Sync:
  [ St_FullSessionEstablished() ]
  --[ Begin() ]->
  [ St_AliceWait(), Out('SYN') ]

rule SyncAck:
  [ In('SYN') ]
  -->
  [ St_BobWait(), Out('SYNACK') ]

rule Ack:
  [ St_AliceWait(), In('SYNACK') ]
  -->
  [ Out('ACK') ]

rule Finish:
  [ St_BobWait(), In('ACK') ]
  --[ End() ]->
  [ St_TCPEstablished() ]

// Session has been setup, TCP has been established 

rule AliceGeneratesKeyPair:
  [ St_FullSessionEstablished(), St_TCPEstablished(), Fr(~sk) ]
  -->
  [!Identity($A, ~sk, pk(~sk))]

 rule AliceChoosesMessage:
   [ !Identity($A, ~sk, pk(~sk)) ]
   --[ St_AliceChoosesMessage() ]->
   [ Out('Hi'), St_AliceChoosesMessage() ]

 rule AliceSignsMessage:
   [ !Identity($A, ~sk, pk(~sk)), In('Hi'), St_AliceChoosesMessage() ]
   --[ St_AliceSentMessage() ]->
   [ Out(sign('Hi', ~sk)), St_AliceSentMessage() ]

 rule BobVerifiesMessage:
  [ In(sign('Hi', ~sk)), !Identity($A, ~sk, pk(~sk)), St_AliceSentMessage() ]
   --[ St_BobVerified() ]->
   [ Out(verify(sign('Hi', ~sk), 'Hi', pk(~sk))), St_BobVerified() ]
 
 rule BobReceivedSigned:
  [ St_BobVerified() ]
  --[ St_BobReceived() ]->
  [ St_BobReceived() ]

 rule BobReceivesUnsigned:
   [ In('Hi'), St_FullSessionEstablished() ]
   --[ St_BobReceived() ]->
   [ St_BobReceived() ]


// ensure session is established after setup
lemma SessionEstablished:
  exists-trace
  "Ex #t. St_FullSessionEstablished() @ #t"

// ensure that Bob gets and verifies a messages
lemma BobReceived:
  exists-trace
  "Ex #t. St_BobReceived() @ #t"

// Bob has received a signed packet from Alice
 lemma SignBobReceived:
   exists-trace
   "Ex #t #j. St_BobVerified() @ t 
     & St_AliceSentMessage() @ j"
 
  // "Ex #t. St_BobReceived() ^ not(Ex. #t'. (St_AliceSentMessage() @ #t') @ #t"

// Bob has received a message, but Alice hasn't signed
lemma UnsignedBobReceived:
exists-trace
"Ex #t. St_BobReceived() @ t"

// lemma Works:
//   exists-trace
//   "Ex #t1 #t2. Begin() @ #t1 & End() @ #t2"

// lemma BulletProof:
//   all-traces
//   "All #t1. Begin() @ #t1 ==> Ex #t2. End() @ #t2 & #t1 < #t2"

/*lemma ConfidentialityOfData:
  all-traces
  "All data #t. Send(data) @ #t ==> (Ex #t1. St_DataReceived() @ #t1 & #t < #t1) & Not Ex #t2. St_Error() @ #t2 & #t < #t2)"
  */
  
// lemma SignedMessagesSecure:
//   all-traces
//   "not(
//     Ex m #t #j. Send(m) @ t
//       & K(m) @ #j
//   )"

// lemma SignedMessagesReadable:
//   all-traces
//     "All m #t. Send(m) @ t ==> Ex A s #j. RevealSign(A, m, s) @ j"

end






// rule DataTransfer:
//   [ St_FullSessionEstablished(), St_TCPEstablished(), In(data) ]
//   --[ Send(data) ]->
//   [ Out(data), St_DataSent() ]

// rule DataReceived:
//   [ In(data) ]
//   -->
//   [ St_DataReceived(), Store(data) ]

// // rule Signed
// rule SignMessage:
//   let 
//     signature = sign(m, sk)
//   in
//   [!Ltk($A, sk), !Pk($A, pk(sk)), Send(m)]
//   --[Sign($A, signature)]->
//   [Store(signature), Verify(signature, m, pk(sk))]

// // rule Unsigned
// rule RevealSignMessage:
//   let
//     revealedSig = revealSign(m, sk)
//   in
//   [!Ltk($A, sk), !Pk($A, pk(sk)), Send(m)]
//   --[RevealSign($A, m, revealedSig)]->
//   [Store(revealedSig), RevealVerify(revealedSig, m, pk(sk))]